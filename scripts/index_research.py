#!/usr/bin/env python3
"""Index research documents by parsing YAML front matter.

Generates docs/research/_INDEX.md from all research files in the same directory.
Run from the project root: python scripts/index_research.py

Staleness detection: if a concluded document has a stale_after field (days)
and enough time has passed since its concluded date, the script updates the
status to stale both in the index and in the source file.
"""

import re
import sys
from datetime import date, timedelta
from pathlib import Path

RESEARCH_DIR = Path("docs/research")
INDEX_FILE = RESEARCH_DIR / "_INDEX.md"
FRONT_MATTER_RE = re.compile(r"^---\s*\n(.*?)\n---", re.DOTALL)
DEFAULT_STALE_AFTER = 90


def parse_front_matter(path: Path) -> dict | None:
    """Extract front matter fields without a YAML dependency."""
    text = path.read_text(encoding="utf-8")
    match = FRONT_MATTER_RE.match(text)
    if not match:
        return None

    fields = {}
    for line in match.group(1).splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue

        key, _, value = line.partition(":")
        key = key.strip()
        value = value.strip()

        # Handle YAML lists: [a, b, c]
        if value.startswith("[") and value.endswith("]"):
            value = [
                v.strip().strip("\"'") for v in value[1:-1].split(",") if v.strip()
            ]

        # Strip surrounding quotes
        elif value.startswith(("'", '"')) and value.endswith(("'", '"')):
            value = value[1:-1]

        # Handle null
        elif value == "null":
            value = None

        fields[key] = value

    return fields


def check_staleness(entry: dict, path: Path, today: date) -> bool:
    """Check if a concluded document has gone stale. Returns True if status was changed."""
    if entry.get("status") != "concluded":
        return False

    concluded = entry.get("concluded")
    if concluded is None:
        return False

    try:
        concluded_date = date.fromisoformat(str(concluded))
    except (ValueError, TypeError):
        return False

    stale_after = entry.get("stale_after", DEFAULT_STALE_AFTER)
    try:
        stale_days = int(stale_after)
    except (ValueError, TypeError):
        stale_days = DEFAULT_STALE_AFTER

    if today - concluded_date <= timedelta(days=stale_days):
        return False

    # Mark stale in source file
    text = path.read_text(encoding="utf-8")
    updated = text.replace("status: concluded", "status: stale", 1)
    if updated != text:
        path.write_text(updated, encoding="utf-8")
        print(f"  stale: {path.name} (concluded {concluded}, {stale_days}d threshold)")

    entry["status"] = "stale"
    return True


def collect_research(directory: Path, today: date) -> list[dict]:
    """Collect and parse all research markdown files."""
    entries = []
    for path in sorted(directory.glob("*.md")):
        if path.name in ("_INDEX.md", "_TEMPLATE.md", "_GUIDE.md"):
            continue
        meta = parse_front_matter(path)
        if meta is None:
            print(f"  warning: no front matter in {path.name}, skipping")
            continue
        meta["filename"] = path.name
        check_staleness(meta, path, today)
        entries.append(meta)
    return entries


def status_icon(status: str) -> str:
    return {
        "draft": "\u270f\ufe0f",
        "active": "\U0001f50d",
        "concluded": "\u2705",
        "stale": "\u26a0\ufe0f",
    }.get(status, "\u2753")


def build_index(entries: list[dict]) -> str:
    lines = [
        "# Research Index",
        "",
        "<!-- Auto-generated by scripts/index_research.py. Do not edit. -->",
        "",
    ]

    # Summary counts
    by_status = {}
    for e in entries:
        s = e.get("status", "unknown")
        by_status[s] = by_status.get(s, 0) + 1

    status_summary = " · ".join(
        f"{status_icon(s)} {s}: {c}" for s, c in sorted(by_status.items())
    )
    lines.append(f"{len(entries)} documents — {status_summary}")
    lines.append("")

    # Main table
    lines.append("| Status | Date | Question | Tags |")
    lines.append("|--------|------|----------|------|")

    for e in entries:
        status = e.get("status", "unknown")
        icon = status_icon(status)
        started = e.get("started", "?")
        question = e.get("question", e["filename"])
        tags = e.get("tags", [])
        tag_str = ", ".join(f"`{t}`" for t in tags) if isinstance(tags, list) else ""
        link = f"[{question}](./{e['filename']})"
        lines.append(f"| {icon} {status} | {started} | {link} | {tag_str} |")

    lines.append("")

    # Tag index
    tag_map: dict[str, list[dict]] = {}
    for e in entries:
        tags = e.get("tags", [])
        if isinstance(tags, list):
            for t in tags:
                tag_map.setdefault(t, []).append(e)

    if tag_map:
        lines.append("## By Tag")
        lines.append("")
        for tag in sorted(tag_map):
            refs = ", ".join(
                f"[{e.get('started', '?')}](./{e['filename']})" for e in tag_map[tag]
            )
            lines.append(f"- **{tag}**: {refs}")
        lines.append("")

    return "\n".join(lines)


def main():
    if not RESEARCH_DIR.is_dir():
        print(f"error: {RESEARCH_DIR} does not exist")
        sys.exit(1)

    today = date.today()
    entries = collect_research(RESEARCH_DIR, today)
    print(f"found {len(entries)} research document(s)")

    index_content = build_index(entries)
    INDEX_FILE.write_text(index_content, encoding="utf-8")
    print(f"wrote {INDEX_FILE}")


if __name__ == "__main__":
    main()
